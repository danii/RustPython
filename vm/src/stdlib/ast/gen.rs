// File automatically generated by ast/asdl_rs.py.

use super::*;

#[pyclass(module = "_ast", name = "Module", base = "AstNode")]
struct NodeModule;
#[pyimpl(flags(HAS_DICT))]
impl NodeModule {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("body"),ctx.new_str("type_ignores")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("body"),ctx.new_str("type_ignores")]));
    }
}
#[pyclass(module = "_ast", name = "Interactive", base = "AstNode")]
struct NodeInteractive;
#[pyimpl(flags(HAS_DICT))]
impl NodeInteractive {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("body")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("body")]));
    }
}
#[pyclass(module = "_ast", name = "Expression", base = "AstNode")]
struct NodeExpression;
#[pyimpl(flags(HAS_DICT))]
impl NodeExpression {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("body")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("body")]));
    }
}
#[pyclass(module = "_ast", name = "FunctionType", base = "AstNode")]
struct NodeFunctionType;
#[pyimpl(flags(HAS_DICT))]
impl NodeFunctionType {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("argtypes"),ctx.new_str("returns")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("argtypes"),ctx.new_str("returns")]));
    }
}
#[pyclass(module = "_ast", name = "FunctionDef", base = "AstNode")]
struct NodeFunctionDef;
#[pyimpl(flags(HAS_DICT))]
impl NodeFunctionDef {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("name"),ctx.new_str("args"),ctx.new_str("body"),ctx.new_str("decorator_list"),ctx.new_str("returns"),ctx.new_str("type_comment")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("name"),ctx.new_str("args"),ctx.new_str("body"),ctx.new_str("decorator_list"),ctx.new_str("returns"),ctx.new_str("type_comment")]));
    }
}
#[pyclass(module = "_ast", name = "AsyncFunctionDef", base = "AstNode")]
struct NodeAsyncFunctionDef;
#[pyimpl(flags(HAS_DICT))]
impl NodeAsyncFunctionDef {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("name"),ctx.new_str("args"),ctx.new_str("body"),ctx.new_str("decorator_list"),ctx.new_str("returns"),ctx.new_str("type_comment")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("name"),ctx.new_str("args"),ctx.new_str("body"),ctx.new_str("decorator_list"),ctx.new_str("returns"),ctx.new_str("type_comment")]));
    }
}
#[pyclass(module = "_ast", name = "ClassDef", base = "AstNode")]
struct NodeClassDef;
#[pyimpl(flags(HAS_DICT))]
impl NodeClassDef {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("name"),ctx.new_str("bases"),ctx.new_str("keywords"),ctx.new_str("body"),ctx.new_str("decorator_list")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("name"),ctx.new_str("bases"),ctx.new_str("keywords"),ctx.new_str("body"),ctx.new_str("decorator_list")]));
    }
}
#[pyclass(module = "_ast", name = "Return", base = "AstNode")]
struct NodeReturn;
#[pyimpl(flags(HAS_DICT))]
impl NodeReturn {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("value")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("value")]));
    }
}
#[pyclass(module = "_ast", name = "Delete", base = "AstNode")]
struct NodeDelete;
#[pyimpl(flags(HAS_DICT))]
impl NodeDelete {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("targets")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("targets")]));
    }
}
#[pyclass(module = "_ast", name = "Assign", base = "AstNode")]
struct NodeAssign;
#[pyimpl(flags(HAS_DICT))]
impl NodeAssign {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("targets"),ctx.new_str("value"),ctx.new_str("type_comment")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("targets"),ctx.new_str("value"),ctx.new_str("type_comment")]));
    }
}
#[pyclass(module = "_ast", name = "AugAssign", base = "AstNode")]
struct NodeAugAssign;
#[pyimpl(flags(HAS_DICT))]
impl NodeAugAssign {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("target"),ctx.new_str("op"),ctx.new_str("value")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("target"),ctx.new_str("op"),ctx.new_str("value")]));
    }
}
#[pyclass(module = "_ast", name = "AnnAssign", base = "AstNode")]
struct NodeAnnAssign;
#[pyimpl(flags(HAS_DICT))]
impl NodeAnnAssign {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("target"),ctx.new_str("annotation"),ctx.new_str("value"),ctx.new_str("simple")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("target"),ctx.new_str("annotation"),ctx.new_str("value"),ctx.new_str("simple")]));
    }
}
#[pyclass(module = "_ast", name = "For", base = "AstNode")]
struct NodeFor;
#[pyimpl(flags(HAS_DICT))]
impl NodeFor {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("target"),ctx.new_str("iter"),ctx.new_str("body"),ctx.new_str("orelse"),ctx.new_str("type_comment")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("target"),ctx.new_str("iter"),ctx.new_str("body"),ctx.new_str("orelse"),ctx.new_str("type_comment")]));
    }
}
#[pyclass(module = "_ast", name = "AsyncFor", base = "AstNode")]
struct NodeAsyncFor;
#[pyimpl(flags(HAS_DICT))]
impl NodeAsyncFor {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("target"),ctx.new_str("iter"),ctx.new_str("body"),ctx.new_str("orelse"),ctx.new_str("type_comment")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("target"),ctx.new_str("iter"),ctx.new_str("body"),ctx.new_str("orelse"),ctx.new_str("type_comment")]));
    }
}
#[pyclass(module = "_ast", name = "While", base = "AstNode")]
struct NodeWhile;
#[pyimpl(flags(HAS_DICT))]
impl NodeWhile {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("test"),ctx.new_str("body"),ctx.new_str("orelse")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("test"),ctx.new_str("body"),ctx.new_str("orelse")]));
    }
}
#[pyclass(module = "_ast", name = "If", base = "AstNode")]
struct NodeIf;
#[pyimpl(flags(HAS_DICT))]
impl NodeIf {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("test"),ctx.new_str("body"),ctx.new_str("orelse")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("test"),ctx.new_str("body"),ctx.new_str("orelse")]));
    }
}
#[pyclass(module = "_ast", name = "With", base = "AstNode")]
struct NodeWith;
#[pyimpl(flags(HAS_DICT))]
impl NodeWith {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("items"),ctx.new_str("body"),ctx.new_str("type_comment")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("items"),ctx.new_str("body"),ctx.new_str("type_comment")]));
    }
}
#[pyclass(module = "_ast", name = "AsyncWith", base = "AstNode")]
struct NodeAsyncWith;
#[pyimpl(flags(HAS_DICT))]
impl NodeAsyncWith {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("items"),ctx.new_str("body"),ctx.new_str("type_comment")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("items"),ctx.new_str("body"),ctx.new_str("type_comment")]));
    }
}
#[pyclass(module = "_ast", name = "Raise", base = "AstNode")]
struct NodeRaise;
#[pyimpl(flags(HAS_DICT))]
impl NodeRaise {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("exc"),ctx.new_str("cause")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("exc"),ctx.new_str("cause")]));
    }
}
#[pyclass(module = "_ast", name = "Try", base = "AstNode")]
struct NodeTry;
#[pyimpl(flags(HAS_DICT))]
impl NodeTry {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("body"),ctx.new_str("handlers"),ctx.new_str("orelse"),ctx.new_str("finalbody")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("body"),ctx.new_str("handlers"),ctx.new_str("orelse"),ctx.new_str("finalbody")]));
    }
}
#[pyclass(module = "_ast", name = "Assert", base = "AstNode")]
struct NodeAssert;
#[pyimpl(flags(HAS_DICT))]
impl NodeAssert {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("test"),ctx.new_str("msg")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("test"),ctx.new_str("msg")]));
    }
}
#[pyclass(module = "_ast", name = "Import", base = "AstNode")]
struct NodeImport;
#[pyimpl(flags(HAS_DICT))]
impl NodeImport {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("names")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("names")]));
    }
}
#[pyclass(module = "_ast", name = "ImportFrom", base = "AstNode")]
struct NodeImportFrom;
#[pyimpl(flags(HAS_DICT))]
impl NodeImportFrom {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("module"),ctx.new_str("names"),ctx.new_str("level")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("module"),ctx.new_str("names"),ctx.new_str("level")]));
    }
}
#[pyclass(module = "_ast", name = "Global", base = "AstNode")]
struct NodeGlobal;
#[pyimpl(flags(HAS_DICT))]
impl NodeGlobal {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("names")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("names")]));
    }
}
#[pyclass(module = "_ast", name = "Nonlocal", base = "AstNode")]
struct NodeNonlocal;
#[pyimpl(flags(HAS_DICT))]
impl NodeNonlocal {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("names")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("names")]));
    }
}
#[pyclass(module = "_ast", name = "Expr", base = "AstNode")]
struct NodeExpr;
#[pyimpl(flags(HAS_DICT))]
impl NodeExpr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("value")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("value")]));
    }
}
#[pyclass(module = "_ast", name = "Pass", base = "AstNode")]
struct NodePass;
#[pyimpl(flags(HAS_DICT))]
impl NodePass {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Break", base = "AstNode")]
struct NodeBreak;
#[pyimpl(flags(HAS_DICT))]
impl NodeBreak {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Continue", base = "AstNode")]
struct NodeContinue;
#[pyimpl(flags(HAS_DICT))]
impl NodeContinue {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "BoolOp", base = "AstNode")]
struct NodeBoolOp;
#[pyimpl(flags(HAS_DICT))]
impl NodeBoolOp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("op"),ctx.new_str("values")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("op"),ctx.new_str("values")]));
    }
}
#[pyclass(module = "_ast", name = "NamedExpr", base = "AstNode")]
struct NodeNamedExpr;
#[pyimpl(flags(HAS_DICT))]
impl NodeNamedExpr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("target"),ctx.new_str("value")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("target"),ctx.new_str("value")]));
    }
}
#[pyclass(module = "_ast", name = "BinOp", base = "AstNode")]
struct NodeBinOp;
#[pyimpl(flags(HAS_DICT))]
impl NodeBinOp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("left"),ctx.new_str("op"),ctx.new_str("right")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("left"),ctx.new_str("op"),ctx.new_str("right")]));
    }
}
#[pyclass(module = "_ast", name = "UnaryOp", base = "AstNode")]
struct NodeUnaryOp;
#[pyimpl(flags(HAS_DICT))]
impl NodeUnaryOp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("op"),ctx.new_str("operand")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("op"),ctx.new_str("operand")]));
    }
}
#[pyclass(module = "_ast", name = "Lambda", base = "AstNode")]
struct NodeLambda;
#[pyimpl(flags(HAS_DICT))]
impl NodeLambda {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("args"),ctx.new_str("body")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("args"),ctx.new_str("body")]));
    }
}
#[pyclass(module = "_ast", name = "IfExp", base = "AstNode")]
struct NodeIfExp;
#[pyimpl(flags(HAS_DICT))]
impl NodeIfExp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("test"),ctx.new_str("body"),ctx.new_str("orelse")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("test"),ctx.new_str("body"),ctx.new_str("orelse")]));
    }
}
#[pyclass(module = "_ast", name = "Dict", base = "AstNode")]
struct NodeDict;
#[pyimpl(flags(HAS_DICT))]
impl NodeDict {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("keys"),ctx.new_str("values")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("keys"),ctx.new_str("values")]));
    }
}
#[pyclass(module = "_ast", name = "Set", base = "AstNode")]
struct NodeSet;
#[pyimpl(flags(HAS_DICT))]
impl NodeSet {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("elts")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("elts")]));
    }
}
#[pyclass(module = "_ast", name = "ListComp", base = "AstNode")]
struct NodeListComp;
#[pyimpl(flags(HAS_DICT))]
impl NodeListComp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("elt"),ctx.new_str("generators")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("elt"),ctx.new_str("generators")]));
    }
}
#[pyclass(module = "_ast", name = "SetComp", base = "AstNode")]
struct NodeSetComp;
#[pyimpl(flags(HAS_DICT))]
impl NodeSetComp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("elt"),ctx.new_str("generators")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("elt"),ctx.new_str("generators")]));
    }
}
#[pyclass(module = "_ast", name = "DictComp", base = "AstNode")]
struct NodeDictComp;
#[pyimpl(flags(HAS_DICT))]
impl NodeDictComp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("key"),ctx.new_str("value"),ctx.new_str("generators")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("key"),ctx.new_str("value"),ctx.new_str("generators")]));
    }
}
#[pyclass(module = "_ast", name = "GeneratorExp", base = "AstNode")]
struct NodeGeneratorExp;
#[pyimpl(flags(HAS_DICT))]
impl NodeGeneratorExp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("elt"),ctx.new_str("generators")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("elt"),ctx.new_str("generators")]));
    }
}
#[pyclass(module = "_ast", name = "Await", base = "AstNode")]
struct NodeAwait;
#[pyimpl(flags(HAS_DICT))]
impl NodeAwait {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("value")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("value")]));
    }
}
#[pyclass(module = "_ast", name = "Yield", base = "AstNode")]
struct NodeYield;
#[pyimpl(flags(HAS_DICT))]
impl NodeYield {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("value")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("value")]));
    }
}
#[pyclass(module = "_ast", name = "YieldFrom", base = "AstNode")]
struct NodeYieldFrom;
#[pyimpl(flags(HAS_DICT))]
impl NodeYieldFrom {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("value")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("value")]));
    }
}
#[pyclass(module = "_ast", name = "Compare", base = "AstNode")]
struct NodeCompare;
#[pyimpl(flags(HAS_DICT))]
impl NodeCompare {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("left"),ctx.new_str("ops"),ctx.new_str("comparators")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("left"),ctx.new_str("ops"),ctx.new_str("comparators")]));
    }
}
#[pyclass(module = "_ast", name = "Call", base = "AstNode")]
struct NodeCall;
#[pyimpl(flags(HAS_DICT))]
impl NodeCall {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("func"),ctx.new_str("args"),ctx.new_str("keywords")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("func"),ctx.new_str("args"),ctx.new_str("keywords")]));
    }
}
#[pyclass(module = "_ast", name = "FormattedValue", base = "AstNode")]
struct NodeFormattedValue;
#[pyimpl(flags(HAS_DICT))]
impl NodeFormattedValue {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("value"),ctx.new_str("conversion"),ctx.new_str("format_spec")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("value"),ctx.new_str("conversion"),ctx.new_str("format_spec")]));
    }
}
#[pyclass(module = "_ast", name = "JoinedStr", base = "AstNode")]
struct NodeJoinedStr;
#[pyimpl(flags(HAS_DICT))]
impl NodeJoinedStr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("values")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("values")]));
    }
}
#[pyclass(module = "_ast", name = "Constant", base = "AstNode")]
struct NodeConstant;
#[pyimpl(flags(HAS_DICT))]
impl NodeConstant {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("value"),ctx.new_str("kind")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("value"),ctx.new_str("kind")]));
    }
}
#[pyclass(module = "_ast", name = "Attribute", base = "AstNode")]
struct NodeAttribute;
#[pyimpl(flags(HAS_DICT))]
impl NodeAttribute {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("value"),ctx.new_str("attr"),ctx.new_str("ctx")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("value"),ctx.new_str("attr"),ctx.new_str("ctx")]));
    }
}
#[pyclass(module = "_ast", name = "Subscript", base = "AstNode")]
struct NodeSubscript;
#[pyimpl(flags(HAS_DICT))]
impl NodeSubscript {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("value"),ctx.new_str("slice"),ctx.new_str("ctx")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("value"),ctx.new_str("slice"),ctx.new_str("ctx")]));
    }
}
#[pyclass(module = "_ast", name = "Starred", base = "AstNode")]
struct NodeStarred;
#[pyimpl(flags(HAS_DICT))]
impl NodeStarred {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("value"),ctx.new_str("ctx")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("value"),ctx.new_str("ctx")]));
    }
}
#[pyclass(module = "_ast", name = "Name", base = "AstNode")]
struct NodeName;
#[pyimpl(flags(HAS_DICT))]
impl NodeName {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("id"),ctx.new_str("ctx")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("id"),ctx.new_str("ctx")]));
    }
}
#[pyclass(module = "_ast", name = "List", base = "AstNode")]
struct NodeList;
#[pyimpl(flags(HAS_DICT))]
impl NodeList {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("elts"),ctx.new_str("ctx")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("elts"),ctx.new_str("ctx")]));
    }
}
#[pyclass(module = "_ast", name = "Tuple", base = "AstNode")]
struct NodeTuple;
#[pyimpl(flags(HAS_DICT))]
impl NodeTuple {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("elts"),ctx.new_str("ctx")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("elts"),ctx.new_str("ctx")]));
    }
}
#[pyclass(module = "_ast", name = "Slice", base = "AstNode")]
struct NodeSlice;
#[pyimpl(flags(HAS_DICT))]
impl NodeSlice {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("lower"),ctx.new_str("upper"),ctx.new_str("step")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("lower"),ctx.new_str("upper"),ctx.new_str("step")]));
    }
}
#[pyclass(module = "_ast", name = "Load", base = "AstNode")]
struct NodeLoad;
#[pyimpl(flags(HAS_DICT))]
impl NodeLoad {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Store", base = "AstNode")]
struct NodeStore;
#[pyimpl(flags(HAS_DICT))]
impl NodeStore {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Del", base = "AstNode")]
struct NodeDel;
#[pyimpl(flags(HAS_DICT))]
impl NodeDel {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "And", base = "AstNode")]
struct NodeAnd;
#[pyimpl(flags(HAS_DICT))]
impl NodeAnd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Or", base = "AstNode")]
struct NodeOr;
#[pyimpl(flags(HAS_DICT))]
impl NodeOr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Add", base = "AstNode")]
struct NodeAdd;
#[pyimpl(flags(HAS_DICT))]
impl NodeAdd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Sub", base = "AstNode")]
struct NodeSub;
#[pyimpl(flags(HAS_DICT))]
impl NodeSub {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Mult", base = "AstNode")]
struct NodeMult;
#[pyimpl(flags(HAS_DICT))]
impl NodeMult {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "MatMult", base = "AstNode")]
struct NodeMatMult;
#[pyimpl(flags(HAS_DICT))]
impl NodeMatMult {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Div", base = "AstNode")]
struct NodeDiv;
#[pyimpl(flags(HAS_DICT))]
impl NodeDiv {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Mod", base = "AstNode")]
struct NodeMod;
#[pyimpl(flags(HAS_DICT))]
impl NodeMod {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Pow", base = "AstNode")]
struct NodePow;
#[pyimpl(flags(HAS_DICT))]
impl NodePow {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "LShift", base = "AstNode")]
struct NodeLShift;
#[pyimpl(flags(HAS_DICT))]
impl NodeLShift {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "RShift", base = "AstNode")]
struct NodeRShift;
#[pyimpl(flags(HAS_DICT))]
impl NodeRShift {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "BitOr", base = "AstNode")]
struct NodeBitOr;
#[pyimpl(flags(HAS_DICT))]
impl NodeBitOr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "BitXor", base = "AstNode")]
struct NodeBitXor;
#[pyimpl(flags(HAS_DICT))]
impl NodeBitXor {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "BitAnd", base = "AstNode")]
struct NodeBitAnd;
#[pyimpl(flags(HAS_DICT))]
impl NodeBitAnd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "FloorDiv", base = "AstNode")]
struct NodeFloorDiv;
#[pyimpl(flags(HAS_DICT))]
impl NodeFloorDiv {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Invert", base = "AstNode")]
struct NodeInvert;
#[pyimpl(flags(HAS_DICT))]
impl NodeInvert {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Not", base = "AstNode")]
struct NodeNot;
#[pyimpl(flags(HAS_DICT))]
impl NodeNot {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "UAdd", base = "AstNode")]
struct NodeUAdd;
#[pyimpl(flags(HAS_DICT))]
impl NodeUAdd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "USub", base = "AstNode")]
struct NodeUSub;
#[pyimpl(flags(HAS_DICT))]
impl NodeUSub {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Eq", base = "AstNode")]
struct NodeEq;
#[pyimpl(flags(HAS_DICT))]
impl NodeEq {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "NotEq", base = "AstNode")]
struct NodeNotEq;
#[pyimpl(flags(HAS_DICT))]
impl NodeNotEq {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Lt", base = "AstNode")]
struct NodeLt;
#[pyimpl(flags(HAS_DICT))]
impl NodeLt {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "LtE", base = "AstNode")]
struct NodeLtE;
#[pyimpl(flags(HAS_DICT))]
impl NodeLtE {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Gt", base = "AstNode")]
struct NodeGt;
#[pyimpl(flags(HAS_DICT))]
impl NodeGt {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "GtE", base = "AstNode")]
struct NodeGtE;
#[pyimpl(flags(HAS_DICT))]
impl NodeGtE {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Is", base = "AstNode")]
struct NodeIs;
#[pyimpl(flags(HAS_DICT))]
impl NodeIs {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "IsNot", base = "AstNode")]
struct NodeIsNot;
#[pyimpl(flags(HAS_DICT))]
impl NodeIsNot {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "In", base = "AstNode")]
struct NodeIn;
#[pyimpl(flags(HAS_DICT))]
impl NodeIn {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "NotIn", base = "AstNode")]
struct NodeNotIn;
#[pyimpl(flags(HAS_DICT))]
impl NodeNotIn {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "comprehension", base = "AstNode")]
struct Nodecomprehension;
#[pyimpl(flags(HAS_DICT))]
impl Nodecomprehension {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("target"),ctx.new_str("iter"),ctx.new_str("ifs"),ctx.new_str("is_async")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("target"),ctx.new_str("iter"),ctx.new_str("ifs"),ctx.new_str("is_async")]));
    }
}
#[pyclass(module = "_ast", name = "ExceptHandler", base = "AstNode")]
struct NodeExceptHandler;
#[pyimpl(flags(HAS_DICT))]
impl NodeExceptHandler {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("type"),ctx.new_str("name"),ctx.new_str("body")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("type"),ctx.new_str("name"),ctx.new_str("body")]));
    }
}
#[pyclass(module = "_ast", name = "arguments", base = "AstNode")]
struct Nodearguments;
#[pyimpl(flags(HAS_DICT))]
impl Nodearguments {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("posonlyargs"),ctx.new_str("args"),ctx.new_str("vararg"),ctx.new_str("kwonlyargs"),ctx.new_str("kw_defaults"),ctx.new_str("kwarg"),ctx.new_str("defaults")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("posonlyargs"),ctx.new_str("args"),ctx.new_str("vararg"),ctx.new_str("kwonlyargs"),ctx.new_str("kw_defaults"),ctx.new_str("kwarg"),ctx.new_str("defaults")]));
    }
}
#[pyclass(module = "_ast", name = "arg", base = "AstNode")]
struct Nodearg;
#[pyimpl(flags(HAS_DICT))]
impl Nodearg {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("arg"),ctx.new_str("annotation"),ctx.new_str("type_comment")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("arg"),ctx.new_str("annotation"),ctx.new_str("type_comment")]));
    }
}
#[pyclass(module = "_ast", name = "keyword", base = "AstNode")]
struct Nodekeyword;
#[pyimpl(flags(HAS_DICT))]
impl Nodekeyword {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("arg"),ctx.new_str("value")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("arg"),ctx.new_str("value")]));
    }
}
#[pyclass(module = "_ast", name = "alias", base = "AstNode")]
struct Nodealias;
#[pyimpl(flags(HAS_DICT))]
impl Nodealias {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("name"),ctx.new_str("asname")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("name"),ctx.new_str("asname")]));
    }
}
#[pyclass(module = "_ast", name = "withitem", base = "AstNode")]
struct Nodewithitem;
#[pyimpl(flags(HAS_DICT))]
impl Nodewithitem {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("context_expr"),ctx.new_str("optional_vars")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("context_expr"),ctx.new_str("optional_vars")]));
    }
}
#[pyclass(module = "_ast", name = "TypeIgnore", base = "AstNode")]
struct NodeTypeIgnore;
#[pyimpl(flags(HAS_DICT))]
impl NodeTypeIgnore {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_str("lineno"),ctx.new_str("tag")]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_str("lineno"),ctx.new_str("tag")]));
    }
}

impl Node for ast::Mod {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = match self {
            ast::Mod::Module { body,type_ignores } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeModule::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_ignores", type_ignores.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::Mod::Interactive { body } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeInteractive::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::Mod::Expression { body } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeExpression::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::Mod::FunctionType { argtypes,returns } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeFunctionType::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("argtypes", argtypes.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("returns", returns.ast_to_object(_vm), _vm).unwrap();
                _node
            }
        };
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}
impl Node for ast::Stmt {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = match self.node {
            ast::StmtKind::FunctionDef { name,args,body,decorator_list,returns,type_comment } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeFunctionDef::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("args", args.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("decorator_list", decorator_list.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("returns", returns.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::AsyncFunctionDef { name,args,body,decorator_list,returns,type_comment } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAsyncFunctionDef::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("args", args.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("decorator_list", decorator_list.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("returns", returns.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::ClassDef { name,bases,keywords,body,decorator_list } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeClassDef::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("bases", bases.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("keywords", keywords.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("decorator_list", decorator_list.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::Return { value } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeReturn::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::Delete { targets } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeDelete::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("targets", targets.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::Assign { targets,value,type_comment } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAssign::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("targets", targets.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::AugAssign { target,op,value } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAugAssign::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("target", target.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::AnnAssign { target,annotation,value,simple } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAnnAssign::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("target", target.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("annotation", annotation.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("simple", simple.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::For { target,iter,body,orelse,type_comment } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeFor::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("target", target.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("iter", iter.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("orelse", orelse.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::AsyncFor { target,iter,body,orelse,type_comment } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAsyncFor::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("target", target.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("iter", iter.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("orelse", orelse.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::While { test,body,orelse } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeWhile::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("test", test.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("orelse", orelse.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::If { test,body,orelse } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeIf::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("test", test.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("orelse", orelse.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::With { items,body,type_comment } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeWith::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("items", items.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::AsyncWith { items,body,type_comment } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAsyncWith::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("items", items.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::Raise { exc,cause } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeRaise::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("exc", exc.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("cause", cause.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::Try { body,handlers,orelse,finalbody } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeTry::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("handlers", handlers.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("orelse", orelse.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("finalbody", finalbody.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::Assert { test,msg } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAssert::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("test", test.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("msg", msg.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::Import { names } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeImport::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("names", names.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::ImportFrom { module,names,level } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeImportFrom::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("module", module.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("names", names.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("level", level.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::Global { names } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeGlobal::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("names", names.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::Nonlocal { names } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeNonlocal::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("names", names.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::Expr { value } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeExpr::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::StmtKind::Pass {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodePass::static_type().clone()).unwrap();
                _node
            }
            ast::StmtKind::Break {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeBreak::static_type().clone()).unwrap();
                _node
            }
            ast::StmtKind::Continue {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeContinue::static_type().clone()).unwrap();
                _node
            }
        };
        node_add_location(&node, self.location, _vm);
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}
impl Node for ast::Expr {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = match self.node {
            ast::ExprKind::BoolOp { op,values } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeBoolOp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("values", values.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::NamedExpr { target,value } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeNamedExpr::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("target", target.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::BinOp { left,op,right } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeBinOp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("left", left.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("right", right.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::UnaryOp { op,operand } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeUnaryOp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("operand", operand.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::Lambda { args,body } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeLambda::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("args", args.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::IfExp { test,body,orelse } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeIfExp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("test", test.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("orelse", orelse.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::Dict { keys,values } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeDict::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("keys", keys.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("values", values.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::Set { elts } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeSet::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("elts", elts.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::ListComp { elt,generators } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeListComp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("elt", elt.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("generators", generators.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::SetComp { elt,generators } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeSetComp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("elt", elt.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("generators", generators.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::DictComp { key,value,generators } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeDictComp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("key", key.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("generators", generators.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::GeneratorExp { elt,generators } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeGeneratorExp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("elt", elt.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("generators", generators.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::Await { value } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAwait::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::Yield { value } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeYield::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::YieldFrom { value } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeYieldFrom::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::Compare { left,ops,comparators } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeCompare::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("left", left.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("ops", ops.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("comparators", comparators.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::Call { func,args,keywords } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeCall::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("func", func.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("args", args.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("keywords", keywords.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::FormattedValue { value,conversion,format_spec } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeFormattedValue::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("conversion", conversion.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("format_spec", format_spec.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::JoinedStr { values } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeJoinedStr::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("values", values.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::Constant { value,kind } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeConstant::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("kind", kind.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::Attribute { value,attr,ctx } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAttribute::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("attr", attr.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::Subscript { value,slice,ctx } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeSubscript::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("slice", slice.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::Starred { value,ctx } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeStarred::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::Name { id,ctx } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeName::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("id", id.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::List { elts,ctx } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeList::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("elts", elts.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::Tuple { elts,ctx } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeTuple::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("elts", elts.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node
            }
            ast::ExprKind::Slice { lower,upper,step } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeSlice::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("lower", lower.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("upper", upper.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("step", step.ast_to_object(_vm), _vm).unwrap();
                _node
            }
        };
        node_add_location(&node, self.location, _vm);
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}
impl Node for ast::ExprContext {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = match self {
            ast::ExprContext::Load {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeLoad::static_type().clone()).unwrap();
                _node
            }
            ast::ExprContext::Store {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeStore::static_type().clone()).unwrap();
                _node
            }
            ast::ExprContext::Del {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeDel::static_type().clone()).unwrap();
                _node
            }
        };
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}
impl Node for ast::Boolop {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = match self {
            ast::Boolop::And {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAnd::static_type().clone()).unwrap();
                _node
            }
            ast::Boolop::Or {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeOr::static_type().clone()).unwrap();
                _node
            }
        };
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}
impl Node for ast::Operator {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = match self {
            ast::Operator::Add {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAdd::static_type().clone()).unwrap();
                _node
            }
            ast::Operator::Sub {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeSub::static_type().clone()).unwrap();
                _node
            }
            ast::Operator::Mult {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeMult::static_type().clone()).unwrap();
                _node
            }
            ast::Operator::MatMult {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeMatMult::static_type().clone()).unwrap();
                _node
            }
            ast::Operator::Div {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeDiv::static_type().clone()).unwrap();
                _node
            }
            ast::Operator::Mod {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeMod::static_type().clone()).unwrap();
                _node
            }
            ast::Operator::Pow {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodePow::static_type().clone()).unwrap();
                _node
            }
            ast::Operator::LShift {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeLShift::static_type().clone()).unwrap();
                _node
            }
            ast::Operator::RShift {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeRShift::static_type().clone()).unwrap();
                _node
            }
            ast::Operator::BitOr {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeBitOr::static_type().clone()).unwrap();
                _node
            }
            ast::Operator::BitXor {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeBitXor::static_type().clone()).unwrap();
                _node
            }
            ast::Operator::BitAnd {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeBitAnd::static_type().clone()).unwrap();
                _node
            }
            ast::Operator::FloorDiv {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeFloorDiv::static_type().clone()).unwrap();
                _node
            }
        };
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}
impl Node for ast::Unaryop {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = match self {
            ast::Unaryop::Invert {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeInvert::static_type().clone()).unwrap();
                _node
            }
            ast::Unaryop::Not {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeNot::static_type().clone()).unwrap();
                _node
            }
            ast::Unaryop::UAdd {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeUAdd::static_type().clone()).unwrap();
                _node
            }
            ast::Unaryop::USub {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeUSub::static_type().clone()).unwrap();
                _node
            }
        };
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}
impl Node for ast::Cmpop {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = match self {
            ast::Cmpop::Eq {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeEq::static_type().clone()).unwrap();
                _node
            }
            ast::Cmpop::NotEq {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeNotEq::static_type().clone()).unwrap();
                _node
            }
            ast::Cmpop::Lt {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeLt::static_type().clone()).unwrap();
                _node
            }
            ast::Cmpop::LtE {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeLtE::static_type().clone()).unwrap();
                _node
            }
            ast::Cmpop::Gt {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeGt::static_type().clone()).unwrap();
                _node
            }
            ast::Cmpop::GtE {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeGtE::static_type().clone()).unwrap();
                _node
            }
            ast::Cmpop::Is {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeIs::static_type().clone()).unwrap();
                _node
            }
            ast::Cmpop::IsNot {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeIsNot::static_type().clone()).unwrap();
                _node
            }
            ast::Cmpop::In {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeIn::static_type().clone()).unwrap();
                _node
            }
            ast::Cmpop::NotIn {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeNotIn::static_type().clone()).unwrap();
                _node
            }
        };
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}
impl Node for ast::Comprehension {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = {
            let ast::Comprehension { target,iter,ifs,is_async } = self;
            let _node = AstNode.into_ref_with_type(_vm, Nodecomprehension::static_type().clone()).unwrap();
            let _dict = _node.as_object().dict().unwrap();
            _dict.set_item("target", target.ast_to_object(_vm), _vm).unwrap();
            _dict.set_item("iter", iter.ast_to_object(_vm), _vm).unwrap();
            _dict.set_item("ifs", ifs.ast_to_object(_vm), _vm).unwrap();
            _dict.set_item("is_async", is_async.ast_to_object(_vm), _vm).unwrap();
            _node
        };
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}
impl Node for ast::Excepthandler {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = match self.node {
            ast::ExcepthandlerKind::ExceptHandler { type_,name,body } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeExceptHandler::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("type", type_.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _node
            }
        };
        node_add_location(&node, self.location, _vm);
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}
impl Node for ast::Arguments {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = {
            let ast::Arguments { posonlyargs,args,vararg,kwonlyargs,kw_defaults,kwarg,defaults } = self;
            let _node = AstNode.into_ref_with_type(_vm, Nodearguments::static_type().clone()).unwrap();
            let _dict = _node.as_object().dict().unwrap();
            _dict.set_item("posonlyargs", posonlyargs.ast_to_object(_vm), _vm).unwrap();
            _dict.set_item("args", args.ast_to_object(_vm), _vm).unwrap();
            _dict.set_item("vararg", vararg.ast_to_object(_vm), _vm).unwrap();
            _dict.set_item("kwonlyargs", kwonlyargs.ast_to_object(_vm), _vm).unwrap();
            _dict.set_item("kw_defaults", kw_defaults.ast_to_object(_vm), _vm).unwrap();
            _dict.set_item("kwarg", kwarg.ast_to_object(_vm), _vm).unwrap();
            _dict.set_item("defaults", defaults.ast_to_object(_vm), _vm).unwrap();
            _node
        };
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}
impl Node for ast::Arg {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = {
            let ast::ArgData { arg,annotation,type_comment } = self.node;
            let _node = AstNode.into_ref_with_type(_vm, Nodearg::static_type().clone()).unwrap();
            let _dict = _node.as_object().dict().unwrap();
            _dict.set_item("arg", arg.ast_to_object(_vm), _vm).unwrap();
            _dict.set_item("annotation", annotation.ast_to_object(_vm), _vm).unwrap();
            _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
            _node
        };
        node_add_location(&node, self.location, _vm);
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}
impl Node for ast::Keyword {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = {
            let ast::KeywordData { arg,value } = self.node;
            let _node = AstNode.into_ref_with_type(_vm, Nodekeyword::static_type().clone()).unwrap();
            let _dict = _node.as_object().dict().unwrap();
            _dict.set_item("arg", arg.ast_to_object(_vm), _vm).unwrap();
            _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
            _node
        };
        node_add_location(&node, self.location, _vm);
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}
impl Node for ast::Alias {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = {
            let ast::Alias { name,asname } = self;
            let _node = AstNode.into_ref_with_type(_vm, Nodealias::static_type().clone()).unwrap();
            let _dict = _node.as_object().dict().unwrap();
            _dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
            _dict.set_item("asname", asname.ast_to_object(_vm), _vm).unwrap();
            _node
        };
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}
impl Node for ast::Withitem {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = {
            let ast::Withitem { context_expr,optional_vars } = self;
            let _node = AstNode.into_ref_with_type(_vm, Nodewithitem::static_type().clone()).unwrap();
            let _dict = _node.as_object().dict().unwrap();
            _dict.set_item("context_expr", context_expr.ast_to_object(_vm), _vm).unwrap();
            _dict.set_item("optional_vars", optional_vars.ast_to_object(_vm), _vm).unwrap();
            _node
        };
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}
impl Node for ast::TypeIgnore {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let node = match self {
            ast::TypeIgnore::TypeIgnore { lineno,tag } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeTypeIgnore::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("lineno", lineno.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("tag", tag.ast_to_object(_vm), _vm).unwrap();
                _node
            }
        };
        node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        todo!()
    }
}

pub fn extend_module_nodes(vm: &VirtualMachine, module: &PyObjectRef) {
    extend_module!(vm, module, {
        "Module" => NodeModule::make_class(&vm.ctx),
        "Interactive" => NodeInteractive::make_class(&vm.ctx),
        "Expression" => NodeExpression::make_class(&vm.ctx),
        "FunctionType" => NodeFunctionType::make_class(&vm.ctx),
        "FunctionDef" => NodeFunctionDef::make_class(&vm.ctx),
        "AsyncFunctionDef" => NodeAsyncFunctionDef::make_class(&vm.ctx),
        "ClassDef" => NodeClassDef::make_class(&vm.ctx),
        "Return" => NodeReturn::make_class(&vm.ctx),
        "Delete" => NodeDelete::make_class(&vm.ctx),
        "Assign" => NodeAssign::make_class(&vm.ctx),
        "AugAssign" => NodeAugAssign::make_class(&vm.ctx),
        "AnnAssign" => NodeAnnAssign::make_class(&vm.ctx),
        "For" => NodeFor::make_class(&vm.ctx),
        "AsyncFor" => NodeAsyncFor::make_class(&vm.ctx),
        "While" => NodeWhile::make_class(&vm.ctx),
        "If" => NodeIf::make_class(&vm.ctx),
        "With" => NodeWith::make_class(&vm.ctx),
        "AsyncWith" => NodeAsyncWith::make_class(&vm.ctx),
        "Raise" => NodeRaise::make_class(&vm.ctx),
        "Try" => NodeTry::make_class(&vm.ctx),
        "Assert" => NodeAssert::make_class(&vm.ctx),
        "Import" => NodeImport::make_class(&vm.ctx),
        "ImportFrom" => NodeImportFrom::make_class(&vm.ctx),
        "Global" => NodeGlobal::make_class(&vm.ctx),
        "Nonlocal" => NodeNonlocal::make_class(&vm.ctx),
        "Expr" => NodeExpr::make_class(&vm.ctx),
        "Pass" => NodePass::make_class(&vm.ctx),
        "Break" => NodeBreak::make_class(&vm.ctx),
        "Continue" => NodeContinue::make_class(&vm.ctx),
        "BoolOp" => NodeBoolOp::make_class(&vm.ctx),
        "NamedExpr" => NodeNamedExpr::make_class(&vm.ctx),
        "BinOp" => NodeBinOp::make_class(&vm.ctx),
        "UnaryOp" => NodeUnaryOp::make_class(&vm.ctx),
        "Lambda" => NodeLambda::make_class(&vm.ctx),
        "IfExp" => NodeIfExp::make_class(&vm.ctx),
        "Dict" => NodeDict::make_class(&vm.ctx),
        "Set" => NodeSet::make_class(&vm.ctx),
        "ListComp" => NodeListComp::make_class(&vm.ctx),
        "SetComp" => NodeSetComp::make_class(&vm.ctx),
        "DictComp" => NodeDictComp::make_class(&vm.ctx),
        "GeneratorExp" => NodeGeneratorExp::make_class(&vm.ctx),
        "Await" => NodeAwait::make_class(&vm.ctx),
        "Yield" => NodeYield::make_class(&vm.ctx),
        "YieldFrom" => NodeYieldFrom::make_class(&vm.ctx),
        "Compare" => NodeCompare::make_class(&vm.ctx),
        "Call" => NodeCall::make_class(&vm.ctx),
        "FormattedValue" => NodeFormattedValue::make_class(&vm.ctx),
        "JoinedStr" => NodeJoinedStr::make_class(&vm.ctx),
        "Constant" => NodeConstant::make_class(&vm.ctx),
        "Attribute" => NodeAttribute::make_class(&vm.ctx),
        "Subscript" => NodeSubscript::make_class(&vm.ctx),
        "Starred" => NodeStarred::make_class(&vm.ctx),
        "Name" => NodeName::make_class(&vm.ctx),
        "List" => NodeList::make_class(&vm.ctx),
        "Tuple" => NodeTuple::make_class(&vm.ctx),
        "Slice" => NodeSlice::make_class(&vm.ctx),
        "Load" => NodeLoad::make_class(&vm.ctx),
        "Store" => NodeStore::make_class(&vm.ctx),
        "Del" => NodeDel::make_class(&vm.ctx),
        "And" => NodeAnd::make_class(&vm.ctx),
        "Or" => NodeOr::make_class(&vm.ctx),
        "Add" => NodeAdd::make_class(&vm.ctx),
        "Sub" => NodeSub::make_class(&vm.ctx),
        "Mult" => NodeMult::make_class(&vm.ctx),
        "MatMult" => NodeMatMult::make_class(&vm.ctx),
        "Div" => NodeDiv::make_class(&vm.ctx),
        "Mod" => NodeMod::make_class(&vm.ctx),
        "Pow" => NodePow::make_class(&vm.ctx),
        "LShift" => NodeLShift::make_class(&vm.ctx),
        "RShift" => NodeRShift::make_class(&vm.ctx),
        "BitOr" => NodeBitOr::make_class(&vm.ctx),
        "BitXor" => NodeBitXor::make_class(&vm.ctx),
        "BitAnd" => NodeBitAnd::make_class(&vm.ctx),
        "FloorDiv" => NodeFloorDiv::make_class(&vm.ctx),
        "Invert" => NodeInvert::make_class(&vm.ctx),
        "Not" => NodeNot::make_class(&vm.ctx),
        "UAdd" => NodeUAdd::make_class(&vm.ctx),
        "USub" => NodeUSub::make_class(&vm.ctx),
        "Eq" => NodeEq::make_class(&vm.ctx),
        "NotEq" => NodeNotEq::make_class(&vm.ctx),
        "Lt" => NodeLt::make_class(&vm.ctx),
        "LtE" => NodeLtE::make_class(&vm.ctx),
        "Gt" => NodeGt::make_class(&vm.ctx),
        "GtE" => NodeGtE::make_class(&vm.ctx),
        "Is" => NodeIs::make_class(&vm.ctx),
        "IsNot" => NodeIsNot::make_class(&vm.ctx),
        "In" => NodeIn::make_class(&vm.ctx),
        "NotIn" => NodeNotIn::make_class(&vm.ctx),
        "comprehension" => Nodecomprehension::make_class(&vm.ctx),
        "ExceptHandler" => NodeExceptHandler::make_class(&vm.ctx),
        "arguments" => Nodearguments::make_class(&vm.ctx),
        "arg" => Nodearg::make_class(&vm.ctx),
        "keyword" => Nodekeyword::make_class(&vm.ctx),
        "alias" => Nodealias::make_class(&vm.ctx),
        "withitem" => Nodewithitem::make_class(&vm.ctx),
        "TypeIgnore" => NodeTypeIgnore::make_class(&vm.ctx),
    })
}
