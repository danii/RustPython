// File automatically generated by ast/asdl_rs.py.

pub use crate::constant::*;
pub use crate::location::Location;

type Ident = String;

#[derive(Debug, PartialEq)]
pub struct Located<T, U = ()> {
    pub location: Location,
    pub custom: U,
    pub node: T,
}

impl<T> Located<T> {
    pub fn new(location: Location, node: T) -> Self {
        Self {
            location,
            custom: (),
            node,
        }
    }
}

#[derive(Debug, PartialEq)]
pub enum Mod<U = ()> {
    Module {
        body: Vec<Stmt<U>>,
        type_ignores: Vec<TypeIgnore>,
    },
    Interactive {
        body: Vec<Stmt<U>>,
    },
    Expression {
        body: Box<Expr<U>>,
    },
    FunctionType {
        argtypes: Vec<Expr<U>>,
        returns: Box<Expr<U>>,
    },
}

#[derive(Debug, PartialEq)]
pub enum StmtKind<U = ()> {
    FunctionDef {
        name: Ident,
        args: Box<Arguments<U>>,
        body: Vec<Stmt<U>>,
        decorator_list: Vec<Expr<U>>,
        returns: Option<Box<Expr<U>>>,
        type_comment: Option<String>,
    },
    AsyncFunctionDef {
        name: Ident,
        args: Box<Arguments<U>>,
        body: Vec<Stmt<U>>,
        decorator_list: Vec<Expr<U>>,
        returns: Option<Box<Expr<U>>>,
        type_comment: Option<String>,
    },
    ClassDef {
        name: Ident,
        bases: Vec<Expr<U>>,
        keywords: Vec<Keyword<U>>,
        body: Vec<Stmt<U>>,
        decorator_list: Vec<Expr<U>>,
    },
    Return {
        value: Option<Box<Expr<U>>>,
    },
    Delete {
        targets: Vec<Expr<U>>,
    },
    Assign {
        targets: Vec<Expr<U>>,
        value: Box<Expr<U>>,
        type_comment: Option<String>,
    },
    AugAssign {
        target: Box<Expr<U>>,
        op: Operator,
        value: Box<Expr<U>>,
    },
    AnnAssign {
        target: Box<Expr<U>>,
        annotation: Box<Expr<U>>,
        value: Option<Box<Expr<U>>>,
        simple: bool,
    },
    For {
        target: Box<Expr<U>>,
        iter: Box<Expr<U>>,
        body: Vec<Stmt<U>>,
        orelse: Vec<Stmt<U>>,
        type_comment: Option<String>,
    },
    AsyncFor {
        target: Box<Expr<U>>,
        iter: Box<Expr<U>>,
        body: Vec<Stmt<U>>,
        orelse: Vec<Stmt<U>>,
        type_comment: Option<String>,
    },
    While {
        test: Box<Expr<U>>,
        body: Vec<Stmt<U>>,
        orelse: Vec<Stmt<U>>,
    },
    If {
        test: Box<Expr<U>>,
        body: Vec<Stmt<U>>,
        orelse: Vec<Stmt<U>>,
    },
    With {
        items: Vec<Withitem<U>>,
        body: Vec<Stmt<U>>,
        type_comment: Option<String>,
    },
    AsyncWith {
        items: Vec<Withitem<U>>,
        body: Vec<Stmt<U>>,
        type_comment: Option<String>,
    },
    Raise {
        exc: Option<Box<Expr<U>>>,
        cause: Option<Box<Expr<U>>>,
    },
    Try {
        body: Vec<Stmt<U>>,
        handlers: Vec<Excepthandler<U>>,
        orelse: Vec<Stmt<U>>,
        finalbody: Vec<Stmt<U>>,
    },
    Assert {
        test: Box<Expr<U>>,
        msg: Option<Box<Expr<U>>>,
    },
    Import {
        names: Vec<Alias>,
    },
    ImportFrom {
        module: Option<Ident>,
        names: Vec<Alias>,
        level: usize,
    },
    Global {
        names: Vec<Ident>,
    },
    Nonlocal {
        names: Vec<Ident>,
    },
    Expr {
        value: Box<Expr<U>>,
    },
    Pass,
    Break,
    Continue,
}
pub type Stmt<U = ()> = Located<StmtKind<U>, U>;

#[derive(Debug, PartialEq)]
pub enum ExprKind<U = ()> {
    BoolOp {
        op: Boolop,
        values: Vec<Expr<U>>,
    },
    NamedExpr {
        target: Box<Expr<U>>,
        value: Box<Expr<U>>,
    },
    BinOp {
        left: Box<Expr<U>>,
        op: Operator,
        right: Box<Expr<U>>,
    },
    UnaryOp {
        op: Unaryop,
        operand: Box<Expr<U>>,
    },
    Lambda {
        args: Box<Arguments<U>>,
        body: Box<Expr<U>>,
    },
    IfExp {
        test: Box<Expr<U>>,
        body: Box<Expr<U>>,
        orelse: Box<Expr<U>>,
    },
    Dict {
        keys: Vec<Option<Box<Expr<U>>>>,
        values: Vec<Expr<U>>,
    },
    Set {
        elts: Vec<Expr<U>>,
    },
    ListComp {
        elt: Box<Expr<U>>,
        generators: Vec<Comprehension<U>>,
    },
    SetComp {
        elt: Box<Expr<U>>,
        generators: Vec<Comprehension<U>>,
    },
    DictComp {
        key: Box<Expr<U>>,
        value: Box<Expr<U>>,
        generators: Vec<Comprehension<U>>,
    },
    GeneratorExp {
        elt: Box<Expr<U>>,
        generators: Vec<Comprehension<U>>,
    },
    Await {
        value: Box<Expr<U>>,
    },
    Yield {
        value: Option<Box<Expr<U>>>,
    },
    YieldFrom {
        value: Box<Expr<U>>,
    },
    Compare {
        left: Box<Expr<U>>,
        ops: Vec<Cmpop>,
        comparators: Vec<Expr<U>>,
    },
    Call {
        func: Box<Expr<U>>,
        args: Vec<Expr<U>>,
        keywords: Vec<Keyword<U>>,
    },
    FormattedValue {
        value: Box<Expr<U>>,
        conversion: Option<ConversionFlag>,
        format_spec: Option<Box<Expr<U>>>,
    },
    JoinedStr {
        values: Vec<Expr<U>>,
    },
    Constant {
        value: Constant,
        kind: Option<String>,
    },
    Attribute {
        value: Box<Expr<U>>,
        attr: Ident,
        ctx: ExprContext,
    },
    Subscript {
        value: Box<Expr<U>>,
        slice: Box<Expr<U>>,
        ctx: ExprContext,
    },
    Starred {
        value: Box<Expr<U>>,
        ctx: ExprContext,
    },
    Name {
        id: Ident,
        ctx: ExprContext,
    },
    List {
        elts: Vec<Expr<U>>,
        ctx: ExprContext,
    },
    Tuple {
        elts: Vec<Expr<U>>,
        ctx: ExprContext,
    },
    Slice {
        lower: Option<Box<Expr<U>>>,
        upper: Option<Box<Expr<U>>>,
        step: Option<Box<Expr<U>>>,
    },
}
pub type Expr<U = ()> = Located<ExprKind<U>, U>;

#[derive(Debug, PartialEq)]
pub enum ExprContext {
    Load,
    Store,
    Del,
}

#[derive(Debug, PartialEq)]
pub enum Boolop {
    And,
    Or,
}

#[derive(Debug, PartialEq)]
pub enum Operator {
    Add,
    Sub,
    Mult,
    MatMult,
    Div,
    Mod,
    Pow,
    LShift,
    RShift,
    BitOr,
    BitXor,
    BitAnd,
    FloorDiv,
}

#[derive(Debug, PartialEq)]
pub enum Unaryop {
    Invert,
    Not,
    UAdd,
    USub,
}

#[derive(Debug, PartialEq)]
pub enum Cmpop {
    Eq,
    NotEq,
    Lt,
    LtE,
    Gt,
    GtE,
    Is,
    IsNot,
    In,
    NotIn,
}

#[derive(Debug, PartialEq)]
pub struct Comprehension<U = ()> {
    pub target: Box<Expr<U>>,
    pub iter: Box<Expr<U>>,
    pub ifs: Vec<Expr<U>>,
    pub is_async: bool,
}

#[derive(Debug, PartialEq)]
pub enum ExcepthandlerKind<U = ()> {
    ExceptHandler {
        type_: Option<Box<Expr<U>>>,
        name: Option<Ident>,
        body: Vec<Stmt<U>>,
    },
}
pub type Excepthandler<U = ()> = Located<ExcepthandlerKind<U>, U>;

#[derive(Debug, PartialEq)]
pub struct Arguments<U = ()> {
    pub posonlyargs: Vec<Arg<U>>,
    pub args: Vec<Arg<U>>,
    pub vararg: Option<Box<Arg<U>>>,
    pub kwonlyargs: Vec<Arg<U>>,
    pub kw_defaults: Vec<Option<Box<Expr<U>>>>,
    pub kwarg: Option<Box<Arg<U>>>,
    pub defaults: Vec<Expr<U>>,
}

#[derive(Debug, PartialEq)]
pub struct ArgData<U = ()> {
    pub arg: Ident,
    pub annotation: Option<Box<Expr<U>>>,
    pub type_comment: Option<String>,
}
pub type Arg<U = ()> = Located<ArgData<U>, U>;

#[derive(Debug, PartialEq)]
pub struct KeywordData<U = ()> {
    pub arg: Option<Ident>,
    pub value: Box<Expr<U>>,
}
pub type Keyword<U = ()> = Located<KeywordData<U>, U>;

#[derive(Debug, PartialEq)]
pub struct Alias {
    pub name: Ident,
    pub asname: Option<Ident>,
}

#[derive(Debug, PartialEq)]
pub struct Withitem<U = ()> {
    pub context_expr: Box<Expr<U>>,
    pub optional_vars: Option<Box<Expr<U>>>,
}

#[derive(Debug, PartialEq)]
pub enum TypeIgnore {
    TypeIgnore { lineno: usize, tag: String },
}
